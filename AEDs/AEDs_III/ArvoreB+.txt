Uma árvore B+ é eficiente para mapear grupos, ou seja, ela agrupa de forma eficiente a ser recuperada, (ou seja, sequencialmente) os alunos de um curso, ou os alunos de uma turma, ou por nome, então todos os gabrieis estariam juntos.

E vai mapear por exemplo

TURMA   ID
1		5234
1		7478
1		8794
2 		1245
2 		1364
2 		4556

Ou seja, não há redundância dos registros. Os registros estão no arquivo de dados, e a arvore é apenas um indice, mas diferente da tabela hash, um indice que agrupa sequencialmente os dados de mesma chave.

Então se eu quiser mostrar todos os dados de todos os registros da turma 1 eu teria que fazer N (N sendo o número de alunos da turma 1) acessos aleatórios (idealmente auxiliados por um indice, tabela hash) para recuperar todos os dados dos alunos da turma 1

Se necessário, (se um dado for mt comumente usado) redundância pode ser introduziada para diminuir a quantidade de acessos aleatórios, sendo assim uma página de uma árvore pode armazenar não pares, mas tuplas como por exemplo <Turma, ID, Nome> os nomes estariam reduntes, ou seja, armazenados tanto no arquivo de dados quanto no indice. E obviamente estariamos gastando mais memoria pra isso.

Mas eu fazer a recuperação das N tuplas da turma 1 você já teria os nomes, e não precisaria fazer os acessos aleatórios. Ótimo para por exemplo a PUC que tem muitos professore fazendo chamadas o tempo todo e mais ou menos nos mesmos momentos.

Sistemas em que há MTs e MTs acessos simultâneos vão introduzir bastante redundancia para garantir os requisitos não funcionais de permormance (velocidade das pesquisas).