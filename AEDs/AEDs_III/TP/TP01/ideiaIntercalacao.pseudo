// Essa implementação deveria supostamente (junto com as outras ideias) deveria ser capaz de lidar com segmentos de tamanho variável,
// e inclusive permite puxar do disco mais segmentos para a ram para dar continuação à intercalação.

public static void foo(int max, Queue[]<T> queueArray) {

	int min = Infinity;
	int pos = -1;
	for (int i = 0; i < queueArray.length; i++) {
		if (!queueArray[i].Empty()) {
			Key k = queueArray[i].getHead().getKey(); // Pensar em como estipular essa key pelo "parametro?"
			if (k >= max && k < min) {
				min = k;
				pos = i;
			}
		}
	}
	
	return pos;
}

{
	int pos = foo(max, queueArray);
	if (pos != -1) {
		// continuarIntercalação
		x = queueArray[pos].remove;
		arquivos[i % 3].push(x);
	}

}